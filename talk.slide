# Testing in Go with Ginkgo and Gomega
Summary: In this talk we will explore testing options in Go beyond the `testing` package. We will go over the most useful features of Ginkgo BDD testing framework and Gomega, the accompanying matcher library. If you feel that your tests could be more expressive, better structured and less repetitive, this talk is for you.

Alexander Egurnov
Team Lead Backend, Verve Group Europe
alexander.egurnov@gmail.com

## About me
: 00:01

* Alexander Egurnov
* Team Lead Backend in Verve Group Europe
* Coding in Go since 2016

: Big projects (hundreds of thousands of lines)
: High load (hundreds of thousands of RPS)

: I've seen projects
: * with tests
: * without tests
: * with useful tests
: * with useless tests, that don't add anything
: * with horrible tests that should not have been written

## About the company
: 00:02

<br>
<img src="img/Verve Group Logo.png" alt="Verve Group Logo" width="400"/>
<br>

* Mobile AdTech
* Product
  * API Services
  * Go, MySQL, Kafka, Redis, Docker, K8s, CI/CD

: Relevant facts
: Influences my perspective

## Plan
: 00:03

* Testing in Go
  * What options are there?
  * How to choose?
* Ginkgo & Gomega overview
  * Specifics
  * Typical mistakes
  * Personal experience

: Starting with an overview ...
: Going to pay special attention to Ginkgo & Gomega ...
: There's going to be lots of code at the end, so bear with me for around 15 minutes.

## For whom is this talk?
: 00:03

* Advanced Go coders
* First experience writing tests
* Growing project
* Eager to try something new

## Questions
: 00:03

* How often do you write tests?
  * Never
  * Sometimes
  * Every day

* What problems do you encounter while writing tests?
  * None
  * It's not my job to write tests
  * Read-only tests: written one and never changed
  * Brittle tests: any code change breaks lots of tests
  * Robust tests: broken code doesn't break tests
  * slow tests
  * Other: send to chat

: My pains:
: * 2 screens of tests, 2 lines of assertions
: * Abandoned tests
: * Tests that are more complex than the code

## What options are there?
: 00:04

## Other stack: Java/Python/etc
: 00:05

* Duplication
* Complexity
  * Development
  * CI/CD
* Extra skill requirements for the team

: * Duplication of solutions
: * Extra mental strain
: * Team changes put the stack at risk
:   * 2 times I've seen tests being abandoned after the original devs left

## Popular options - 2020
: 00:05

.image img/JetBrains_survey_2020_highlighted.png _ 700
.caption Source: [[https://www.jetbrains.com/lp/devecosystem-2020/go/][JetBrains - The State of Developer Ecosystem 2020]]

## Popular options - 2021
: 00:05

.image img/JetBrains_survey_2021_highlighted.png _ 700
.caption Source: [[https://www.jetbrains.com/lp/devecosystem-2021/go/][JetBrains - The State of Developer Ecosystem 2021]]

## testing
: 00:06

`+` Standard  
`+` Simple  
`-` Verbose  

: + Covers lots, if not most, cases.
: - No assertions library

## testing
: 00:06

//.code src/testing_test.go /BEGIN testing1/,/END testing1/
<img style="margin-top:20px" src="img/code-133/testing1.png" alt="testing1"/>

## testing
: 00:06

//.code src/testing_test.go /BEGIN testing2/,/END testing2/
<img style="margin-top:20px" src="img/code-133/testing2.png" alt="testing2"/>

## testify
: 00:07

* assert
* require
* mock
* suite

## testify
: 00:07

`+` Complements testing  
`+` Rich API  
`+` Setup/teardown - suite  
`+` Mocking - mock  
`?` Convenience?  
`-` Limited extendability  

: + complements built-in testing package well
: + rich assertion library - on par with Ginkgo
: ± no Domain Specific Language
: - not extendable
: - API could be improved (personal taste)
: - typical mistake - swap actual and expected

## testify
: 00:07

//.code src/testify_test.go /BEGIN testify1/,/END testify1/
<img style="margin-top:20px" src="img/code-133/testify1.png" alt="testify1"/>

## Typical mistake
: 00:08

//.code src/testify_test.go /BEGIN testify-out/,/END testify-out/
<img style="margin-top:20px" src="img/code-133/testify-out.png" alt="testify-out"/>

## Ginkgo & Gomega
: 00:08

`+` Structure  
`+` Setup / teardown  
`+` Rich DSL  
`+` Close to natural language  
`+` Extendable  
`-` Complex  

: + Structure
: + Rich DSL
: + Reads close to natural language
: + Can combine existing matchers and write your own
: - Easy to overcomplicate things

## How to choose?
: 00:08

## When?
: 00:10

* It becomes hard to
  * read
  * write
  * change
* Testing harness grows too large
  * setup / teardown
  * assertions, helpers, checkers, etc
  * API clients

: * too much boilerplate
: * Obscure logic
: * Assertions, helpers, checkers, etc take too much time to learn
: * And they need their own debugging =)

## Harness
: 00:11

// .image img/harness1.jpg
// .image img/harness2.jpg
<table>
  <tr>
    <td style="border: 0px">
      <figure>
        <img src="img/harness1.jpg" alt="climbing harness" width="400"/>
        <figcaption style="font-size: 16px">Source: <a href="https://en.wikipedia.org/wiki/Climbing_harness">https://en.wikipedia.org/wiki/Climbing_harness</a></figcaption>
      </figure>
    </td>
    <td style="border: 0px">
      <figure>
        <img src="img/harness2.jpg" alt="horse harness" width="400"/>
        <figcaption style="font-size: 16px">Source: <a href="https://en.wikipedia.org/wiki/Horse_harness">https://en.wikipedia.org/wiki/Horse_harness</a></figcaption>
      </figure>
    </td>
  </tr>
</table>

## Why?
: 00:12

* Simplify
  * reading
  * writing
* Remove duplicates
* Write tests, not harness
* Bonus: portability

: * easier to read and understand
: * easier to write - write more - more tests!
: * reduce duplication
: * don't reinvent the wheel
: * try BDD

: Can't always take existing code into a new project

## DRY vs DAMP
: 00:13

* DRY - Don’t Repeat Yourself
* DAMP - Descriptive And Meaningful Phrases

: DRY
: Good: write once, use often
: Bad: poor abstractions

: DAMP
: Good - explicit, verbose, where you need it
: Clear is better than clever.

## Proverb
: 00:13

.image img/clear.png
.caption Source: [[https://dave.cheney.net/paste/clear-is-better-than-clever.pdf][Dave Cheney - GopherCon Singapore 2019]]

## Proverb
: 00:13

Links:
* Clear is better than clever <sub>[https://dave.cheney.net/2019/07/09/clear-is-better-than-clever](https://dave.cheney.net/2019/07/09/clear-is-better-than-clever)</sub>
* Go Proverbs <sub>[https://go-proverbs.github.io/](https://go-proverbs.github.io/)</sub>

: Rob Pike

## Testing pyramid
: 00:14

* End2End - the whole product, blackbox
* Integration - several components
* Unit - one function or struct

.image img/testPyramid_mine.png _ 500
.caption Adapted from [[https://martinfowler.com/articles/practical-test-pyramid.html][martinfowler.com - The Practical Test Pyramid]]

: Tests are tools, you need different tests for different things

: Not universal definitions, but bear with me.

: Personal choice:
:   * testing+testify for unit and functional tests;
:   * ginkgo+gomega for end-to-end tests.

: Let me tell you why...

## Ginkgo & Gomega
: 00:15

: Now that we've figured out when to use it, let's dive into some code.
: And see how not to turn this solution into one more problem. =)

## What is it?
: 00:15

* Ginkgo
  * Framework
      * dictates structure
      * controls your code
  * [https://onsi.github.io/ginkgo/](https://onsi.github.io/ginkgo/)
* Gomega
  * Assertion library
      * helps you make assertion
      * is controlled by your code
  * [http://onsi.github.io/gomega/](http://onsi.github.io/gomega/)

: inversion of control

## Specifics
: 00:15

: Read the docs!
: Only touching on some specifics

## Ginkgo
: 00:16

## Testing support
: 00:16

//.code src/ginkgo_talk_2021_suite_test.go /BEGIN suite/,/END suite/ HLrun
<img style="margin-top:20px" src="img/code-133/suite-HLrun.png" alt="suite"/>

## Testing tree
: 00:17

//.code src/tree_test.go /BEGIN tree/,/END tree/
<img style="margin-top:20px" src="img/code-133/tree.png" alt="tree"/>

## Testing tree
: 00:17

Two steps
* Build
* Execute

**Warning:** Closures!

: Don't mix these two.

## Setup/Teardown
: 00:18

//.code src/tree_test.go /BEGIN setup-tree/,/END setup-tree/
<img style="margin-top:20px" src="img/code-133/setup-tree.png" alt="setup-tree"/>

## Setup/Teardown
: 00:18

//.code src/tree_test.go /BEGIN setup-res/,/END setup-res/
<img style="margin-top:20px" src="img/code-133/setup-res.png" alt="setup-res"/>

## Focus/Skip/Pending
: 00:18

//.code src/tree_test.go /BEGIN focus/,/END focus/
<img style="margin-top:20px" src="img/code-133/focus.png" alt="focus"/>

: Ever run the whole suite instead of just one test?
: Advanced IDE helps
: Breaks CI/CD - non-zero return

## GinkgoWriter
: 00:19

//.code src/ginkgo_talk_2021_suite_test.go /BEGIN suite/,/END suite/ HLgw
<img style="margin-top:20px" src="img/code-133/suite-HLgw.png" alt="suite"/>

: Signal-to-noise

## Gomega
: 00:19

## Independent use
: 00:20

//.code src/gomega_standalone_test.go /BEGIN gomega/,/END gomega/
<img style="margin-top:20px" src="img/code-133/gomega.png" alt="gomega"/>

## Matchers
: 00:20

: What's a matcher?
: Familiar from  testify

//.code src/matchers_test.go /BEGIN matchers1/,/END matchers1/
<img style="margin-top:20px" src="img/code-133/matchers1.png" alt="matchers1"/>

## Matchers
: 00:21

//.code src/matchers_test.go /BEGIN matchers2/,/END matchers2/
<img style="margin-top:20px" src="img/code-133/matchers2.png" alt="matchers2"/>

## Matchers
: 00:21

//.code src/matchers_test.go /BEGIN eventually/,/END eventually/
<img style="margin-top:20px" src="img/code-133/eventually.png" alt="eventually"/>

## Matchers - Combining
: 00:22

//.code src/combination_test.go /BEGIN combine/,/END combine/
<img style="margin-top:20px" src="img/code-133/combine.png" alt="combine"/>

## Matchers - Transforming
: 00:22

//.code src/combination_test.go /BEGIN transform/,/END transform/
<img style="margin-top:20px" src="img/code-133/transform.png" alt="transform"/>

## Typical mistakes
: 00:23

## Comparing heterogeneous values
: 00:23

//.code src/foot_shots_test.go /BEGIN TypeConv/,/END TypeConv/
<img style="margin-top:20px" src="img/code-133/TypeConv.png" alt="TypeConv"/>

: "assert" is affected as well

## ContainElement / ContainSubstring
: 00:24

//.code src/foot_shots_test.go /BEGIN ContainElement/,/END ContainElement/
<img style="margin-top:20px" src="img/code-133/ContainElement.png" alt="ContainElement"/>

: "assert" is affected as well

## Eventually
: 00:24

//.code src/foot_shots_test.go /BEGIN Eventually/,/END Eventually/
<img style="margin-top:20px" src="img/code-133/Eventually-shots.png" alt="Eventually"/>

: Замечательно работает с каналами и функциями.
: Не предназначен для статичных значений, но работает и с ними.

## Closures
: 00:25

//.code src/foot_shots_test.go /BEGIN closures1/,/END closures1/
<img style="margin-top:20px" src="img/code-133/closures1.png" alt="closures1"/>

## Closures
: 00:25

//.code src/foot_shots_test.go /BEGIN closures2/,/END closures2/
<img style="margin-top:20px" src="img/code-133/closures2.png" alt="closures2"/>

## Loop variable
: 00:26

//.code src/foot_shots_test.go /BEGIN Loop1/,/END Loop1/
<img style="margin-top:20px" src="img/code-133/Loop1.png" alt="Loop1"/>
<br>
//.code src/foot_shots_test.go /BEGIN Loop1-res/,/END Loop1-res/
<img style="margin-top:20px" src="img/code-133/Loop1-res.png" alt="Loop1-res"/>

## Loop variable
: 00:26

//.code src/foot_shots_test.go /BEGIN Loop2/,/END Loop2/
<img style="margin-top:20px" src="img/code-133/Loop2.png" alt="Loop2"/>
<br>
//.code src/foot_shots_test.go /BEGIN Loop2-res/,/END Loop2-res/
<img style="margin-top:20px" src="img/code-133/Loop2-res.png" alt="Loop2-res"/>

## GinkgoRecover
: 00:26

: Forgot to GinkgoRecover?
: Will fail noisily

: Dies in goroutine - dies in "real world"

//.code src/foot_shots_test.go /BEGIN recover1/,/END recover1/
<img style="margin-top:20px" src="img/code-133/recover1.png" alt="recover1"/>
<br>
//.code src/foot_shots_test.go /BEGIN recover1-res/,/END recover1-res/
<img style="margin-top:20px" src="img/code-133/recover1-res.png" alt="recover1-res"/>

## GinkgoRecover
: 00:26

//.code src/foot_shots_test.go /BEGIN recover2/,/END recover2/
<img style="margin-top:20px" src="img/code-133/recover2.png" alt="recover2"/>
<br>
//.code src/foot_shots_test.go /BEGIN recover2-res/,/END recover2-res/
<img style="margin-top:20px" src="img/code-133/recover2-res.png" alt="recover2-res"/>

## Asynchronous tests
: 00:27

//.code src/foot_shots_test.go /BEGIN async1/,/END async1/
<img style="margin-top:20px" src="img/code-133/async1.png" alt="async1"/>
<br>
//.code src/foot_shots_test.go /BEGIN async1-res/,/END async1-res/
<img style="margin-top:20px" src="img/code-133/async1-res.png" alt="async1-res"/>

## Asynchronous tests
: 00:27

//.code src/foot_shots_test.go /BEGIN async2/,/END async2/
<img style="margin-top:20px" src="img/code-133/async2.png" alt="async2"/>
<br>
//.code src/foot_shots_test.go /BEGIN async2-res/,/END async2-res/
<img style="margin-top:20px" src="img/code-133/async2-res.png" alt="async2-res"/>

## Personal experience
: 00:28

## Positive
: 00:29

* Automation
* Readability
* Simplicity
* Code reuse
* Portability

: * Abandoned manual testing after wrote enough e2e tests.
: * Easier to read
: * Fast onboarding
: * Easy code reuse, don't focus on setup/teardown
: * Gomega can be used without Ginkgo

## Negative
: 00:29

* Gotchas
* Complexity
* Readability >_<

: * Ginkgo&Gomega has its gotchas: hidden type casting in assertions; different matcher behavior for different types, etc
: * Easy to mess up async code (as usual)
: * Complex use of BeforeEach/JustBeforeEach/BeforeSuit can hurt readability
: * 10000 repetitions vs nesting hell
: * Lack of overview. (>1k lines)

## Conclusion
: 00:30

* Write tests!
* Write different tests
* Pick you tools
* Start with a broken test
* Don't overcomplicate, seek balance

: Start with failing, fix afterwards

## Links
: 00:30

* This talk
  * Code [https://github.com/egurnov/ginkgo-talk-2021-pub/tree/english](https://github.com/egurnov/ginkgo-talk-2021-pub/tree/english)

* Previous talk
  * Code [https://github.com/egurnov/ginkgo-talk-2020](https://github.com/egurnov/ginkgo-talk-2020)
  * Video [https://youtu.be/FaDx5GTlXNE](https://youtu.be/FaDx5GTlXNE)
